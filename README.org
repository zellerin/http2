#+TITLE: http/2 in Common Lisp

This is a (work in progress) implementation of http/2 protocol as described in
RFC7540 and RFC7541.

The core part of the library is implementing reading and writing http2
frames. What to do with the frames is managed by classes ~CONNECTION~ and
~HTTP2-STREAM~ that are supposed to be extended by application to do something
reasonable with headers and payload; see [[./client.lisp]] for an example.

** Status and quickstart
Already implemented parts allow to request a http/2 document (or more) over TLS:

*** Client
#+begin_src lisp
  (ql:quickload 'http2/client)
  (http2/client:retrieve-url "https://example.com")
#+end_src

#+begin_src text
  "<!doctype html>
  <html>
  <head>
      <title>Example Domain</title>

      <meta charset="utf-8" />
      <meta http-equiv="Content-type" content="text/html; charset=utf-8" />
      <meta name="viewport" conten...[sly-elided string of length 1256]"
  (("content-length" . "1256") ("x-cache" . "HIT") ("vary" . "Accept-Encoding")
   ("server" . "ECS (bsa/EB23)")
   ("last-modified" . "Thu, 17 Oct 2019 07:18:26 GMT")
   ("expires" . "Fri, 10 Jun 2022 19:43:07 GMT")
   ("etag" . "\"3147526947+ident\"") ("date" . "Fri, 03 Jun 2022 19:43:07 GMT")
   ("content-type" . "text/html; charset=UTF-8")
   ("cache-control" . "max-age=604800") ("age" . "495733") (:STATUS . 200))
#+end_src

*** Server
Rudimentary https server (that signals h2 support with ALPN) is implemented; Key and cert are needed. It handles requests one by one, this is trivial to improve in several ways (thread for request, workers, polling...) but out of scope of this.

#+begin_src lisp
  (ql:quickload 'http2/server)
  (http2::create-server 1234 "key.pem" "cert.pem")
#+end_src

and point your browser (not eww nor drakma, of course - must support http2) to https://localhost:1234 or
#+begin_src sh
  [zellerin@winter http2]$ curl http://localhost:1234/
  Hello World
#+end_src

Customize PEER-ENDS-HTTP-STREAM to send something else (or process-end-headers if you do not want to see their data), and maybe add a method to ADD-HEADER to pay attention to what other headers than URL the client sends.

** Missing pieces
- Window management is minimal. We should limit outgoing data as required by the
  peer. This depends on application that sends the data.
- RFC accepts that individual headers can be split between frames. This is not implemented (and should be).
- No handling of priorities is implemented. This is OK, as these are only suggestions.
- Push promises are not implemented. This is OK, they are disabled by default (settings)
- Dynamic table is not used for encoding and decoding headers. This is OK, header table size is set to 0

** Implementation details

- [[./frames.lisp]] implements frame reading and writing. It is intended to be
  correct and fast, in this order. Read frames call callbacks that are supposed
  to be generic functions for extensibility.
- [[./classes.lisp]] defines class hierarchy for vanilla connections and streams,
  and the generic methods for callbacks for these classes.

** License
Licensed by MIT license.

Significant part of the comments is taken over from the RFCs above and
copyrighted by RFC contributors. I read the copyright licenses for RFC that this
is allowed. Big chunks of RFC text mean usually something is not implemented and are slowly converted to code.

** Related software
There is an Akamai code on https://github.com/akamai/cl-http2-protocol that
supported bigger parts of the drafted HTTP/2 protocol in 2014; apparently hard
to run now, used NPN instead of ALPN. It might be reasonable to pilfer some
pieces and ideas (especially interface level) from that one, but I have not done
so (yet).
